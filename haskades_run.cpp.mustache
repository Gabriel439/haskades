#include <QtDebug>
#include <QLocale>
#include <QTranslator>
#include <bb/cascades/Application>
#include <bb/cascades/QmlDocument>
#include <bb/cascades/AbstractPane>

#ifdef USE_SENSORS
#include <QtSensors/QAccelerometer>
#endif

#ifdef USE_NOTIFICATIONS
#include <bb/platform/Notification>
#include <bb/platform/NotificationDialog>
#endif

QEvent::Type customSignalEventType;
{{#signals}}
#define CUSTOM_SIGNAL_{{signame}} {{sigevent}}
{{/signals}}

class CustomSignalEvent : public QEvent {

public:
	CustomSignalEvent(int signalEvent{{#signalTypes}}, {{qtsigtype}} {{sigtypename}}{{/signalTypes}}) : QEvent(customSignalEventType) {
		this->signalEvent = signalEvent;
{{#signalTypes}}
		this->{{sigtypename}} = {{sigtypename}};
{{/signalType}}
	}

	int signalEvent;
{{#signalTypes}}
	{{qtsigtype}} {{sigtypename}};
{{/signalType}}
};

class AppWrapper: public QObject {
Q_OBJECT

public:
	// This is our constructor that sets up the recipe.
	AppWrapper(QString qml_path{{#slots}}, void (*_{{name}})({{#args}}{{^firstarg}}, {{/firstarg}}{{lowctype}} {{aname}}{{/args}}){{/slots}}) :
	qmlPath(qml_path){{#slots}},
	_{{name}}(_{{name}}){{/slots}}
	{
#ifdef USE_NOTIFICATIONS
qmlRegisterType<bb::platform::Notification>("bb.platform", 1, 0, "Notification");
qmlRegisterType<bb::platform::NotificationDialog>("bb.platform", 1, 0, "NotificationDialog");
#endif
	}

	virtual void ready() {
		// Obtain a QMLDocument and load it into the qml variable, using build patterns.
		bb::cascades::QmlDocument *qml = bb::cascades::QmlDocument::create(this->qmlPath);

		// If the QML document is valid, we process it.
		if(!qml->hasErrors()) {
			qml->setContextProperty("app", this);

			// Create the application root from QMLDocument
			bb::cascades::AbstractPane *appPage = qml->createRootObject<bb::cascades::AbstractPane>();

			if (appPage) {
				// Set the main scene for the application to the Page.
				bb::cascades::Application::instance()->setScene(appPage);
			}
		} else {
			qCritical() << qml->errors();
		}
	}

	virtual bool event(QEvent *e) {
		if(e->type() == customSignalEventType) {
			CustomSignalEvent *ev = (CustomSignalEvent*)e;
			switch(ev->signalEvent) {
{{#signals}}
				case CUSTOM_SIGNAL_{{signame}}:
					emit {{signame}}({{#sigargs}}{{^sigargfirst}}, {{/sigargfirst}}ev->{{sigargsigtypename}}{{/sigargs}});
					return true;
					break;
{{/signals}}
			}
			return false;
		} else {
			return QObject::event(e);
		}
	}

public slots:
{{#slots}}
	Q_INVOKABLE void {{name}}({{#args}}{{^firstarg}}, {{/firstarg}}{{qttype}} {{aname}}{{/args}}) {
		_{{name}}({{#args}}{{^firstarg}}, {{/firstarg}}{{qtunwrap}}{{/args}});
	}
{{/slots}}

signals:
{{#signals}}
	void {{signame}}({{#sigargs}}{{^sigargfirst}}, {{/sigargfirst}}{{qtsigargtype}}{{/sigargs}});
{{/signals}}

protected:
	QString qmlPath;
{{#slots}}
	void (*_{{name}})({{#args}}{{^firstarg}}, {{/firstarg}}{{lowctype}} {{aname}}{{/args}});
{{/slots}}
};

#ifdef USE_SENSORS
class AccelerometerHandler : public QObject {
Q_OBJECT

public:
	AccelerometerHandler(QtMobility::QAccelerometer::AccelerationMode accelM, QtMobility::QAccelerometer::AxesOrientationMode axesM, int (*cb)(double, double, double)) : _cb(cb) {
		_accel.setAccelerationMode(accelM);
		_accel.setAxesOrientationMode(axesM);

		connect(&_accel, SIGNAL(readingChanged()), SLOT(callback()));

		if(!_accel.connectToBackend()) {
			qCritical() << "CONNECT TO ACCELEROMETER BACKEND FAILED!";
		} else if(!_accel.start()) {
			qCritical() << "ACCELEROMETER START FAILED!";
		}
	}

public slots:
	void callback() {
		QtMobility::QAccelerometerReading *r = _accel.reading();
		if(!_cb((double)r->x(), (double)r->y(), (double)r->z())) {
			_accel.stop();
			delete this;
		}
	}

protected:
	QtMobility::QAccelerometer _accel;
	int (*_cb)(double, double, double);
};
#endif

extern "C" {

QObject *mainAppGlobal;

void emit_CustomSignalEvent(int signalEvent{{#signalTypes}}, {{lowcsigtype}} {{sigtypename}}{{/signalTypes}}) {
	QEvent *e = (QEvent *)new CustomSignalEvent(signalEvent{{#signalTypes}}, {{qtwrapsig}}{{/signalTypes}});
	QCoreApplication::postEvent(mainAppGlobal, e);
}

int haskades_run(char *qml_path{{#slots}}, void (*_{{name}})({{#args}}{{^firstarg}}, {{/firstarg}}{{lowctype}} {{aname}}{{/args}}){{/slots}}) {
	int argc = 0;
	char *argv[] = { NULL };
	// Instantiate the main application constructor.
	bb::cascades::Application app(argc, argv);

	// Set up the translator.
	QTranslator translator;
	QString locale_string = QLocale().name();
	QString filename = QString("sample_%1").arg(locale_string); // TODO
	if (translator.load(filename, "app/native/qm")) {
		app.installTranslator(&translator);
	}

	customSignalEventType = (QEvent::Type)QEvent::registerEventType();

	// Initialize our application.
	AppWrapper mainApp(QString::fromUtf8(qml_path){{#slots}}, _{{name}}{{/slots}});
	mainAppGlobal = (QObject*)&mainApp;
	mainApp.ready();

	// We complete the transaction started in the main application constructor and start the
	// client event loop here. When loop is exited the Application deletes the scene which
	// deletes all its children.
	return bb::cascades::Application::exec();
}

#ifdef USE_SENSORS
void accelerometer_start(int accelM, int axesM, int (*cb)(double, double, double)) {
	QtMobility::QAccelerometer::AccelerationMode _accelM;
	QtMobility::QAccelerometer::AxesOrientationMode _axesM;

	switch(accelM) {
		case 0:
			_accelM = QtMobility::QAccelerometer::Gravity;
			break;
		case 1:
			_accelM = QtMobility::QAccelerometer::User;
			break;
		case 2:
			_accelM = QtMobility::QAccelerometer::Combined;
			break;
		default:
			qWarning() << "Unknown AccelerationMode, defaulting to Combined";
			_accelM = QtMobility::QAccelerometer::Combined;
	}

	switch(axesM) {
		case 0:
			_axesM = QtMobility::QAccelerometer::FixedOrientation;
			break;
		case 1:
			_axesM = QtMobility::QAccelerometer::AutomaticOrientation;
			break;
		case 2:
			_axesM = QtMobility::QAccelerometer::UserOrientation;
			break;
		default:
			qWarning() << "Unknown AxesOrientationMode, defaulting to Automatic";
			_axesM = QtMobility::QAccelerometer::AutomaticOrientation;
	}

	new AccelerometerHandler(_accelM, _axesM, cb);
}
#endif

}

// Tell MOC to run on this file
#include "haskades_run.moc"
